{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lefi A discord API wrapper focused on clean code, and usability Features Asynchronous - Almost everything is async except for few unavoidable ones. Object oriented - Allows for easy usage Get started here","title":"Home"},{"location":"#lefi","text":"A discord API wrapper focused on clean code, and usability","title":"Lefi"},{"location":"#features","text":"Asynchronous - Almost everything is async except for few unavoidable ones. Object oriented - Allows for easy usage Get started here","title":"Features"},{"location":"getting-started/","text":"Getting started Table of contents Installation Basic usage Installing To install the wrapper you can use pip , poetry or any other manager you use. Note: It is recommended to use poetry or any other venv when downloading Poetry poetry add git+https://github.com/an-dyy/Lefi.git Pip pip install git+https://github.com/an-dyy/Lefi.git Examples import os import asyncio import lefi async def main () -> None : token = os . getenv ( \"discord_token\" ) # NOTE: I'm on linux so I can just export, windows might need a `.env` client = lefi . Client ( token ) # type: ignore @client . on ( \"message_create\" ) async def message_create ( message : lefi . Message ) -> None : print ( message ) await client . start () asyncio . run ( main ())","title":"Getting-Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#table-of-contents","text":"Installation Basic usage","title":"Table of contents"},{"location":"getting-started/#installing","text":"To install the wrapper you can use pip , poetry or any other manager you use. Note: It is recommended to use poetry or any other venv when downloading Poetry poetry add git+https://github.com/an-dyy/Lefi.git Pip pip install git+https://github.com/an-dyy/Lefi.git","title":"Installing"},{"location":"getting-started/#examples","text":"import os import asyncio import lefi async def main () -> None : token = os . getenv ( \"discord_token\" ) # NOTE: I'm on linux so I can just export, windows might need a `.env` client = lefi . Client ( token ) # type: ignore @client . on ( \"message_create\" ) async def message_create ( message : lefi . Message ) -> None : print ( message ) await client . start () asyncio . run ( main ())","title":"Examples"},{"location":"API-Reference/client/","text":"A class used to communicate with the discord API and its gateway. Attributes: Name Type Description pub_key Optional[str] The client's public key. Used when handling interactions over HTTP. loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop which is being used. http lefi.HTTPClient The HTTPClient to use for handling requests to the API. ws lefi.WebSocketClient The WebSocketClient which handles the gateway. __init__ ( self , token , * , intents = None , pub_key = None , loop = None ) special Parameters: Name Type Description Default token str The clients token, used for authorization (logging in, etc...) This is required. required intents Optional[lefi.Intents] The intents to be used for the client. None pub_key Optional[str] The public key of the client. Only pass if you want interactions over HTTP. None loop Optional[asyncio.AbstractEventLoop] The loop to use. None Source code in lefi/client.py def __init__ ( self , token : str , * , intents : Intents = None , pub_key : Optional [ str ] = None , loop : Optional [ asyncio . AbstractEventLoop ] = None , ): \"\"\" Parameters: token (str): The clients token, used for authorization (logging in, etc...) This is required. intents (Optional[lefi.Intents]): The intents to be used for the client. pub_key (Optional[str]): The public key of the client. Only pass if you want interactions over HTTP. loop (Optional[asyncio.AbstractEventLoop]): The loop to use. \"\"\" self . pub_key : Optional [ str ] = pub_key self . loop : asyncio . AbstractEventLoop = loop or asyncio . get_event_loop () self . http : HTTPClient = HTTPClient ( token , self . loop ) self . _state : State = State ( self , self . loop ) self . ws : WebSocketClient = WebSocketClient ( self , intents ) self . events : Dict [ str , List [ Callable [ ... , Any ]]] = {} self . once_events : Dict [ str , List [ Callable [ ... , Any ]]] = {} self . futures : Dict [ str , List [ Tuple [ asyncio . Future , Callable [ ... , bool ]]]] = {} add_listener ( self , func , event_name ) Registers listener, basically connecting an event to a callback. Parameters: Name Type Description Default func Callable[..., Coroutine] The callback to register for an event. required event_name Optional[str] The event to register, if None it will pass the decorated functions name. required Source code in lefi/client.py def add_listener ( self , func : Callable [ ... , Coroutine ], event_name : Optional [ str ], ) -> None : \"\"\" Registers listener, basically connecting an event to a callback. Parameters: func (Callable[..., Coroutine]): The callback to register for an event. event_name (Optional[str]): The event to register, if None it will pass the decorated functions name. \"\"\" name = event_name or func . __name__ if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Callback must be a coroutine\" ) callbacks = self . events . setdefault ( name , []) callbacks . append ( func ) on ( self , event_name = None ) A decorator that registers the decorated function to an event. Parameters: Name Type Description Default event_name Optional[str] The event to register. None Note The function being decorated must be a coroutine. Multiple functions can be decorated with the same event. Although you will need to pass the event name and give functions different names. And if no event name is passed it defaults to the functions name. Returns: Type Description Callable[..., Callable[..., Coroutine]] The decorated function after registering it as a listener. Source code in lefi/client.py def on ( self , event_name : Optional [ str ] = None ) -> Callable [ ... , Callable [ ... , Coroutine ]]: \"\"\" A decorator that registers the decorated function to an event. Parameters: event_name (Optional[str]): The event to register. Note: The function being decorated must be a coroutine. Multiple functions can be decorated with the same event. Although you will need to pass the event name and give functions different names. And if no event name is passed it defaults to the functions name. Returns: The decorated function after registering it as a listener. \"\"\" def inner ( func : Callable [ ... , Coroutine ]) -> Callable [ ... , Coroutine ]: self . add_listener ( func , event_name ) return func return inner once ( self , event_name = None ) A decorator that registers the decorated function to an event. Similar to lefi.Client.on but also cuts itself off the event after firing once. Meaning it will only run once. Parameters: Name Type Description Default event_name Optional[str] The event to register. None Note Functions must be coroutines. Multiple functions can be decorated with this that have the same event. Functions decorated with lefi.Client.once take precedence over the regular events. Returns: Type Description Callable[..., Callable[..., Coroutine]] The decorated function after registering it as a listener. Source code in lefi/client.py def once ( self , event_name : Optional [ str ] = None ) -> Callable [ ... , Callable [ ... , Coroutine ]]: \"\"\" A decorator that registers the decorated function to an event. Similar to [lefi.Client.on][] but also cuts itself off the event after firing once. Meaning it will only run once. Parameters: event_name (Optional[str]): The event to register. Note: Functions must be coroutines. Multiple functions can be decorated with this that have the same event. Functions decorated with [lefi.Client.once][] take precedence over the regular events. Returns: The decorated function after registering it as a listener. \"\"\" def inner ( func : Callable [ ... , Coroutine ]) -> Callable [ ... , Coroutine ]: name = event_name or func . __name__ if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Callback must be a coroutine\" ) callbacks = self . once_events . setdefault ( name , []) callbacks . append ( func ) return func return inner connect ( self ) async A method which starts the connection to the gateway. Source code in lefi/client.py async def connect ( self ) -> None : \"\"\" A method which starts the connection to the gateway. \"\"\" await self . ws . start () login ( self ) async A method which \"logs\" in with the token to make sure it is valid. This is to make sure that proper authorization has been passed. Source code in lefi/client.py async def login ( self ) -> None : \"\"\" A method which \"logs\" in with the token to make sure it is valid. This is to make sure that proper authorization has been passed. \"\"\" await self . http . login () start ( self ) async A method which calls lefi.Client.login and lefi.Client.connect in that order. If pub_key is passed to the clients constructor it also creates an HTTP server to handle interactions. Source code in lefi/client.py async def start ( self ) -> None : \"\"\" A method which calls [lefi.Client.login][] and [lefi.Client.connect][] in that order. If `pub_key` is passed to the clients constructor it also creates an HTTP server to handle interactions. \"\"\" if self . pub_key : self . server = App ( self , self . pub_key ) await self . server . run () await asyncio . gather ( self . login (), self . connect ()) get_message ( self , id ) Grabs a lefi.Message instance if cached. Parameters: Name Type Description Default id int The message's ID. required Returns: Type Description Optional[Message] The lefi.Message instance related to the ID. Else None if not found. Source code in lefi/client.py def get_message ( self , id : int ) -> Optional [ Message ]: \"\"\" Grabs a [lefi.Message][] instance if cached. Parameters: id (int): The message's ID. Returns: The [lefi.Message][] instance related to the ID. Else None if not found. \"\"\" return self . _state . get_message ( id ) get_guild ( self , id ) Grabs a lefi.Guild instance if cached. Parameters: Name Type Description Default id int The guild's ID. required Returns: Type Description Optional[Guild] The lefi.Guild instance related to the ID. Else None if not found Source code in lefi/client.py def get_guild ( self , id : int ) -> Optional [ Guild ]: \"\"\" Grabs a [lefi.Guild][] instance if cached. Parameters: id (int): The guild's ID. Returns: The [lefi.Guild][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_guild ( id ) get_channel ( self , id ) Grabs a lefi.Channel instance if cached. Parameters: Name Type Description Default id int The channel's ID. required Returns: Type Description Optional[Union[TextChannel, VoiceChannel, DMChannel, CategoryChannel, Channel]] The lefi.Channel instance related to the ID. Else None if not found Source code in lefi/client.py def get_channel ( self , id : int ) -> Optional [ Union [ TextChannel , VoiceChannel , DMChannel , CategoryChannel , Channel ]]: \"\"\" Grabs a [lefi.Channel][] instance if cached. Parameters: id (int): The channel's ID. Returns: The [lefi.Channel][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_channel ( id ) get_user ( self , id ) Grabs a lefi.User instance if cached. Parameters: Name Type Description Default id int The user's ID. required Returns: Type Description Optional[User] The lefi.User instance related to the ID. Else None if not found Source code in lefi/client.py def get_user ( self , id : int ) -> Optional [ User ]: \"\"\" Grabs a [lefi.User][] instance if cached. Parameters: id (int): The user's ID. Returns: The [lefi.User][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_user ( id ) wait_for ( self , event , * , check = None , timeout = None ) async Waits for an event to be dispatched that passes the check. Parameters: Name Type Description Default event str The event to wait for. required check Callable[..., bool] A function that takes the same args as the event, and returns a bool. None timeout float The time to wait before stopping. None Returns: Type Description Any The return from a callback that matches with the event you are waiting for. Note The check has to take in the same args as the event. If no check is passed, everything will complete the check. Source code in lefi/client.py async def wait_for ( self , event : str , * , check : Callable [ ... , bool ] = None , timeout : float = None ) -> Any : \"\"\" Waits for an event to be dispatched that passes the check. Parameters: event (str): The event to wait for. check (Callable[..., bool]): A function that takes the same args as the event, and returns a bool. timeout (float): The time to wait before stopping. Returns: The return from a callback that matches with the event you are waiting for. Note: The check has to take in the same args as the event. If no check is passed, everything will complete the check. \"\"\" future = self . loop . create_future () futures = self . futures . setdefault ( event , []) if check is None : check = lambda * args : True futures . append (( future , check )) return await asyncio . wait_for ( future , timeout = timeout )","title":"Client"},{"location":"API-Reference/client/#lefi.client.Client.__init__","text":"Parameters: Name Type Description Default token str The clients token, used for authorization (logging in, etc...) This is required. required intents Optional[lefi.Intents] The intents to be used for the client. None pub_key Optional[str] The public key of the client. Only pass if you want interactions over HTTP. None loop Optional[asyncio.AbstractEventLoop] The loop to use. None Source code in lefi/client.py def __init__ ( self , token : str , * , intents : Intents = None , pub_key : Optional [ str ] = None , loop : Optional [ asyncio . AbstractEventLoop ] = None , ): \"\"\" Parameters: token (str): The clients token, used for authorization (logging in, etc...) This is required. intents (Optional[lefi.Intents]): The intents to be used for the client. pub_key (Optional[str]): The public key of the client. Only pass if you want interactions over HTTP. loop (Optional[asyncio.AbstractEventLoop]): The loop to use. \"\"\" self . pub_key : Optional [ str ] = pub_key self . loop : asyncio . AbstractEventLoop = loop or asyncio . get_event_loop () self . http : HTTPClient = HTTPClient ( token , self . loop ) self . _state : State = State ( self , self . loop ) self . ws : WebSocketClient = WebSocketClient ( self , intents ) self . events : Dict [ str , List [ Callable [ ... , Any ]]] = {} self . once_events : Dict [ str , List [ Callable [ ... , Any ]]] = {} self . futures : Dict [ str , List [ Tuple [ asyncio . Future , Callable [ ... , bool ]]]] = {}","title":"__init__()"},{"location":"API-Reference/client/#lefi.client.Client.add_listener","text":"Registers listener, basically connecting an event to a callback. Parameters: Name Type Description Default func Callable[..., Coroutine] The callback to register for an event. required event_name Optional[str] The event to register, if None it will pass the decorated functions name. required Source code in lefi/client.py def add_listener ( self , func : Callable [ ... , Coroutine ], event_name : Optional [ str ], ) -> None : \"\"\" Registers listener, basically connecting an event to a callback. Parameters: func (Callable[..., Coroutine]): The callback to register for an event. event_name (Optional[str]): The event to register, if None it will pass the decorated functions name. \"\"\" name = event_name or func . __name__ if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Callback must be a coroutine\" ) callbacks = self . events . setdefault ( name , []) callbacks . append ( func )","title":"add_listener()"},{"location":"API-Reference/client/#lefi.client.Client.on","text":"A decorator that registers the decorated function to an event. Parameters: Name Type Description Default event_name Optional[str] The event to register. None Note The function being decorated must be a coroutine. Multiple functions can be decorated with the same event. Although you will need to pass the event name and give functions different names. And if no event name is passed it defaults to the functions name. Returns: Type Description Callable[..., Callable[..., Coroutine]] The decorated function after registering it as a listener. Source code in lefi/client.py def on ( self , event_name : Optional [ str ] = None ) -> Callable [ ... , Callable [ ... , Coroutine ]]: \"\"\" A decorator that registers the decorated function to an event. Parameters: event_name (Optional[str]): The event to register. Note: The function being decorated must be a coroutine. Multiple functions can be decorated with the same event. Although you will need to pass the event name and give functions different names. And if no event name is passed it defaults to the functions name. Returns: The decorated function after registering it as a listener. \"\"\" def inner ( func : Callable [ ... , Coroutine ]) -> Callable [ ... , Coroutine ]: self . add_listener ( func , event_name ) return func return inner","title":"on()"},{"location":"API-Reference/client/#lefi.client.Client.once","text":"A decorator that registers the decorated function to an event. Similar to lefi.Client.on but also cuts itself off the event after firing once. Meaning it will only run once. Parameters: Name Type Description Default event_name Optional[str] The event to register. None Note Functions must be coroutines. Multiple functions can be decorated with this that have the same event. Functions decorated with lefi.Client.once take precedence over the regular events. Returns: Type Description Callable[..., Callable[..., Coroutine]] The decorated function after registering it as a listener. Source code in lefi/client.py def once ( self , event_name : Optional [ str ] = None ) -> Callable [ ... , Callable [ ... , Coroutine ]]: \"\"\" A decorator that registers the decorated function to an event. Similar to [lefi.Client.on][] but also cuts itself off the event after firing once. Meaning it will only run once. Parameters: event_name (Optional[str]): The event to register. Note: Functions must be coroutines. Multiple functions can be decorated with this that have the same event. Functions decorated with [lefi.Client.once][] take precedence over the regular events. Returns: The decorated function after registering it as a listener. \"\"\" def inner ( func : Callable [ ... , Coroutine ]) -> Callable [ ... , Coroutine ]: name = event_name or func . __name__ if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Callback must be a coroutine\" ) callbacks = self . once_events . setdefault ( name , []) callbacks . append ( func ) return func return inner","title":"once()"},{"location":"API-Reference/client/#lefi.client.Client.connect","text":"A method which starts the connection to the gateway. Source code in lefi/client.py async def connect ( self ) -> None : \"\"\" A method which starts the connection to the gateway. \"\"\" await self . ws . start ()","title":"connect()"},{"location":"API-Reference/client/#lefi.client.Client.login","text":"A method which \"logs\" in with the token to make sure it is valid. This is to make sure that proper authorization has been passed. Source code in lefi/client.py async def login ( self ) -> None : \"\"\" A method which \"logs\" in with the token to make sure it is valid. This is to make sure that proper authorization has been passed. \"\"\" await self . http . login ()","title":"login()"},{"location":"API-Reference/client/#lefi.client.Client.start","text":"A method which calls lefi.Client.login and lefi.Client.connect in that order. If pub_key is passed to the clients constructor it also creates an HTTP server to handle interactions. Source code in lefi/client.py async def start ( self ) -> None : \"\"\" A method which calls [lefi.Client.login][] and [lefi.Client.connect][] in that order. If `pub_key` is passed to the clients constructor it also creates an HTTP server to handle interactions. \"\"\" if self . pub_key : self . server = App ( self , self . pub_key ) await self . server . run () await asyncio . gather ( self . login (), self . connect ())","title":"start()"},{"location":"API-Reference/client/#lefi.client.Client.get_message","text":"Grabs a lefi.Message instance if cached. Parameters: Name Type Description Default id int The message's ID. required Returns: Type Description Optional[Message] The lefi.Message instance related to the ID. Else None if not found. Source code in lefi/client.py def get_message ( self , id : int ) -> Optional [ Message ]: \"\"\" Grabs a [lefi.Message][] instance if cached. Parameters: id (int): The message's ID. Returns: The [lefi.Message][] instance related to the ID. Else None if not found. \"\"\" return self . _state . get_message ( id )","title":"get_message()"},{"location":"API-Reference/client/#lefi.client.Client.get_guild","text":"Grabs a lefi.Guild instance if cached. Parameters: Name Type Description Default id int The guild's ID. required Returns: Type Description Optional[Guild] The lefi.Guild instance related to the ID. Else None if not found Source code in lefi/client.py def get_guild ( self , id : int ) -> Optional [ Guild ]: \"\"\" Grabs a [lefi.Guild][] instance if cached. Parameters: id (int): The guild's ID. Returns: The [lefi.Guild][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_guild ( id )","title":"get_guild()"},{"location":"API-Reference/client/#lefi.client.Client.get_channel","text":"Grabs a lefi.Channel instance if cached. Parameters: Name Type Description Default id int The channel's ID. required Returns: Type Description Optional[Union[TextChannel, VoiceChannel, DMChannel, CategoryChannel, Channel]] The lefi.Channel instance related to the ID. Else None if not found Source code in lefi/client.py def get_channel ( self , id : int ) -> Optional [ Union [ TextChannel , VoiceChannel , DMChannel , CategoryChannel , Channel ]]: \"\"\" Grabs a [lefi.Channel][] instance if cached. Parameters: id (int): The channel's ID. Returns: The [lefi.Channel][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_channel ( id )","title":"get_channel()"},{"location":"API-Reference/client/#lefi.client.Client.get_user","text":"Grabs a lefi.User instance if cached. Parameters: Name Type Description Default id int The user's ID. required Returns: Type Description Optional[User] The lefi.User instance related to the ID. Else None if not found Source code in lefi/client.py def get_user ( self , id : int ) -> Optional [ User ]: \"\"\" Grabs a [lefi.User][] instance if cached. Parameters: id (int): The user's ID. Returns: The [lefi.User][] instance related to the ID. Else None if not found \"\"\" return self . _state . get_user ( id )","title":"get_user()"},{"location":"API-Reference/client/#lefi.client.Client.wait_for","text":"Waits for an event to be dispatched that passes the check. Parameters: Name Type Description Default event str The event to wait for. required check Callable[..., bool] A function that takes the same args as the event, and returns a bool. None timeout float The time to wait before stopping. None Returns: Type Description Any The return from a callback that matches with the event you are waiting for. Note The check has to take in the same args as the event. If no check is passed, everything will complete the check. Source code in lefi/client.py async def wait_for ( self , event : str , * , check : Callable [ ... , bool ] = None , timeout : float = None ) -> Any : \"\"\" Waits for an event to be dispatched that passes the check. Parameters: event (str): The event to wait for. check (Callable[..., bool]): A function that takes the same args as the event, and returns a bool. timeout (float): The time to wait before stopping. Returns: The return from a callback that matches with the event you are waiting for. Note: The check has to take in the same args as the event. If no check is passed, everything will complete the check. \"\"\" future = self . loop . create_future () futures = self . futures . setdefault ( event , []) if check is None : check = lambda * args : True futures . append (( future , check )) return await asyncio . wait_for ( future , timeout = timeout )","title":"wait_for()"},{"location":"API-Reference/errors/","text":"BadRequest ( HTTPException ) Represents a 400 error Forbidden ( HTTPException ) Represents a 403 error HTTPException ( Exception ) Error representing an error received from the API. Attributes: Name Type Description data Union[Dict[str, Any], str] data received from the API. messsage str The message for the error. code int The code of the error. NotFound ( HTTPException ) Represents a 404 error Unauthorized ( HTTPException ) Represents a 401 error","title":"Errors"},{"location":"API-Reference/errors/#lefi.errors.BadRequest","text":"Represents a 400 error","title":"BadRequest"},{"location":"API-Reference/errors/#lefi.errors.Forbidden","text":"Represents a 403 error","title":"Forbidden"},{"location":"API-Reference/errors/#lefi.errors.HTTPException","text":"Error representing an error received from the API. Attributes: Name Type Description data Union[Dict[str, Any], str] data received from the API. messsage str The message for the error. code int The code of the error.","title":"HTTPException"},{"location":"API-Reference/errors/#lefi.errors.NotFound","text":"Represents a 404 error","title":"NotFound"},{"location":"API-Reference/errors/#lefi.errors.Unauthorized","text":"Represents a 401 error","title":"Unauthorized"},{"location":"API-Reference/http/","text":"A class used to send and handle requests to the discord API. Attributes: Name Type Description token str The clients token, used for authorization. loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop being used. session aiohttp.ClientSession The aiohttp.ClientSession to use for sending requests. Note This class is used behind the scenes, this is not intended to be called directly. __init__ ( self , token , loop ) special Parameters: Name Type Description Default token str The token to use for authorzation. required loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop to use. required session aiohttp.ClientSession The aiohttp.ClientSession to use for sending requests. required Source code in lefi/http.py def __init__ ( self , token : str , loop : asyncio . AbstractEventLoop ) -> None : \"\"\" Parameters: token (str): The token to use for authorzation. loop (asyncio.AbstractEventLoop): The [asyncio.AbstractEventLoop][] to use. session (aiohttp.ClientSession): The [aiohttp.ClientSession][] to use for sending requests. \"\"\" self . token : str = token self . loop : asyncio . AbstractEventLoop = loop self . session : aiohttp . ClientSession = None # type: ignore request ( self , method , path , ** kwargs ) async Makes a request to the discord API. Parameters: Name Type Description Default method str The method for the request. required path str The endpoint which to send the request to. required **kwargs Any Any extra options to pass to aiohttp.ClientSession.request {} Returns: Type Description Any The data returned from the request. Source code in lefi/http.py async def request ( self , method : str , path : str , ** kwargs ) -> Any : \"\"\" Makes a request to the discord API. Parameters: method (str): The method for the request. path (str): The endpoint which to send the request to. **kwargs (Any): Any extra options to pass to [aiohttp.ClientSession.request][] Returns: The data returned from the request. Raises: [lefi.errors.HTTPException][] if any error was received from the request. \"\"\" if self . session is None or self . session . closed : self . session = await self . _create_session () url = BASE + path async with self . session . request ( method , url , ** kwargs ) as resp : try : data = await resp . json () except aiohttp . ContentTypeError : data = await resp . text () if resp . status in ( 200 , 201 , 204 , 304 ): return data if resp . status == 429 : retry_after = float ( data [ \"retry_after\" ]) # type: ignore await asyncio . sleep ( retry_after ) return await self . request ( method = method , path = path , ** kwargs ) error = self . ERRORS . get ( resp . status , HTTPException ) raise error ( data ) get_bot_gateway ( self ) async A method which gets the gateway url. Returns: Type Description Dict A dict which should contain the url. Source code in lefi/http.py async def get_bot_gateway ( self ) -> Dict : \"\"\" A method which gets the gateway url. Returns: A dict which should contain the url. \"\"\" return await self . request ( \"GET\" , \"/gateway/bot\" ) ws_connect ( self , url ) async A method which attempts to connect to the websocket. Returns: Type Description aiohttp.ClientWebSocketResponse A aiohttp.ClientWebSocketResponse instance. Source code in lefi/http.py async def ws_connect ( self , url : str ) -> aiohttp . ClientWebSocketResponse : \"\"\" A method which attempts to connect to the websocket. Returns: A [aiohttp.ClientWebSocketResponse][] instance. \"\"\" return await self . session . ws_connect ( url ) login ( self ) async Checks to see if the token given is valid. Source code in lefi/http.py async def login ( self ) -> None : \"\"\" Checks to see if the token given is valid. Raises: ValueError if an invalid token was passed. \"\"\" try : await self . request ( \"GET\" , \"/users/@me\" ) except ( Forbidden , Unauthorized ): raise ValueError ( \"Invalid token\" ) get_channel ( self , channel_id ) async Makes an API call to get a channel. Parameters: Name Type Description Default channel_id int The channel's ID. required Returns: Type Description Dict[str, Any] A dict representing the channel. Source code in lefi/http.py async def get_channel ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a channel. Parameters: channel_id (int): The channel's ID. Returns: A dict representing the channel. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } \" ) edit_text_channel ( self , channel_id , * , name = None , type = None , position = None , topic = None , nsfw = None , rate_limit_per_user = None , permission_overwrites = None , default_auto_archive_duration = None ) async Makes an API call to edit a text channel. Parameters: Name Type Description Default channel_id int The channel id representing the channel to edit. required name Optional[str] The new name for the channel. None type Optional[int] The new type for the channel. None position Optional[int] The new position for the channel. None topic Optional[str] The new topic for the channel. None nsfw Optional[bool] Whether or not the channel should be NSFW. None rate_limit_per_user Optional[int] The new slowmode of the channel. None permissions_overwrites Optional[List[Dict[str, Any]]] The new permission overwrites for the channel. required default_auto_archive_duration Optional[List[Dict[str, Any]]] New time for threads to auto archive. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def edit_text_channel ( self , channel_id : int , * , name : Optional [ str ] = None , type : Optional [ int ] = None , position : Optional [ int ] = None , topic : Optional [ str ] = None , nsfw : Optional [ bool ] = None , rate_limit_per_user : Optional [ int ] = None , permission_overwrites : Optional [ List [ Dict [ str , Any ]]] = None , default_auto_archive_duration : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a text channel. Parameters: channel_id (int): The channel id representing the channel to edit. name (Optional[str]): The new name for the channel. type (Optional[int]): The new type for the channel. position (Optional[int]): The new position for the channel. topic (Optional[str]): The new topic for the channel. nsfw (Optional[bool]): Whether or not the channel should be NSFW. rate_limit_per_user (Optional[int]): The new slowmode of the channel. permissions_overwrites (Optional[List[Dict[str, Any]]]): The new permission overwrites for the channel. default_auto_archive_duration (Optional[List[Dict[str, Any]]]): New time for threads to auto archive. Returns: The data received from the API after making the call. \"\"\" payload = update_payload ( {}, name = name , type = type , position = position , topic = topic , nsfw = nsfw , rate_limit_per_user = rate_limit_per_user , permission_overwrites = permission_overwrites , default_auto_archive_duration = default_auto_archive_duration , ) return await self . request ( \"PATCH\" , f \"/channels/ { channel_id } \" , json = payload ) edit_voice_channel ( self , channel_id , * , name = None , position = None , bitrate = None , user_limit = None , rtc_region = None , video_quality_mode = None , sync_permissions = None , permissions_overwrites = None ) async Makes an API call to edit a voice channel. Parameters: Name Type Description Default channel_id int The ID representing the voice channel to edit. required name Optional[str] The new name to give the channel. None position Optional[int] The new position of the channel. None bitrate Optional[int] The new bitrate of the channel. None user_limit Optional[int] The new user limit of the channel. None rtc_region Optional[str] The new rtc region of the channel. None video_quality_mode Optional[int] The new video quality of the channel. None sync_permissions Optional[bool] Whether or not to sync the permissions. None permissions_overwrites Optional[List[Dict[str, Any]]] The new permissions ovewrites for the channel. None Returns: Type Description Dict[str, Any] The data received from the API after the call. Source code in lefi/http.py async def edit_voice_channel ( self , channel_id : int , * , name : Optional [ str ] = None , position : Optional [ int ] = None , bitrate : Optional [ int ] = None , user_limit : Optional [ int ] = None , rtc_region : Optional [ str ] = None , video_quality_mode : Optional [ int ] = None , sync_permissions : Optional [ bool ] = None , permissions_overwrites : Optional [ List [ Dict [ str , Any ]]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a voice channel. Parameters: channel_id (int): The ID representing the voice channel to edit. name (Optional[str]): The new name to give the channel. position (Optional[int]): The new position of the channel. bitrate (Optional[int]): The new bitrate of the channel. user_limit (Optional[int]): The new user limit of the channel. rtc_region (Optional[str]): The new rtc region of the channel. video_quality_mode (Optional[int]): The new video quality of the channel. sync_permissions (Optional[bool]): Whether or not to sync the permissions. permissions_overwrites (Optional[List[Dict[str, Any]]]): The new permissions ovewrites for the channel. Returns: The data received from the API after the call. \"\"\" payload = update_payload ( {}, name = name , position = position , bitrate = bitrate , user_limit = user_limit , rtc_region = rtc_region , video_quality_mode = video_quality_mode , sync_permissions = sync_permissions , permissions_overwrites = permissions_overwrites , ) return await self . request ( \"PATCH\" , f \"/channels/ { channel_id } \" , json = payload ) get_channel_messages ( self , channel_id , * , around = None , before = None , after = None , limit = 50 ) async Makes an API call to get a list of messages in a channel. Only returns messages within the range of the parameters passed. Parameters: Name Type Description Default channel_id int The ID representing the channel. required around Optional[int] Gets messages around this message ID. None before Optional[int] Gets messages before this message ID. None after Optional[int] Gets messages after this message ID. None limit int THe amount of messages to grab. 50 Returns: Type Description Dict[str, Any] The data received after making the call. Source code in lefi/http.py async def get_channel_messages ( self , channel_id : int , * , around : Optional [ int ] = None , before : Optional [ int ] = None , after : Optional [ int ] = None , limit : int = 50 , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a list of messages in a channel. Only returns messages within the range of the parameters passed. Parameters: channel_id (int): The ID representing the channel. around (Optional[int]): Gets messages around this message ID. before (Optional[int]): Gets messages before this message ID. after (Optional[int]): Gets messages after this message ID. limit (int): THe amount of messages to grab. Returns: The data received after making the call. \"\"\" params = { \"limit\" : limit } update_payload ( params , around = around , before = before , after = after ) return await self . request ( \"GET\" , f \"/channels/ { channel_id } /messages\" , params = params ) get_channel_message ( self , channel_id , message_id ) async Makes an API call to get a specific message by ID. Parameters: Name Type Description Default channel_id int The channel ID which the message is in. required message_id int The messages ID. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_channel_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a specific message by ID. Parameters: channel_id (int): The channel ID which the message is in. message_id (int): The messages ID. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } /messages/ { message_id } \" ) send_message ( self , channel_id , content = None , * , tts = False , embeds = None , allowed_mentions = None , message_reference = None , components = None , sticker_ids = None ) async Makes an API call to send a message. Parameters: Name Type Description Default channel_id int The ID of the channel which to send the message in. required content Optional[str] The content of the message. None tts bool Whether or not to send the message with text-to-speech. False embed Optional[List[Dict[str, Any]]] The embed to show when sending the message. required embeds Optional[List[Dict[str, Any]]] The list of embeds to send. None message_reference Optional[Dict[str, Any]] The messages to reference when sending the message. None components Optional[List[Dict[str, Any]]] The components to attach to the message. None sticker_ids Optional[List[int]] The stickers to send with the message. None Note Max embeds that can sent at a time is 10. Source code in lefi/http.py async def send_message ( self , channel_id : int , content : Optional [ str ] = None , * , tts : bool = False , embeds : Optional [ List [ Dict [ str , Any ]]] = None , allowed_mentions : Optional [ Dict [ str , Any ]] = None , message_reference : Optional [ Dict [ str , Any ]] = None , components : Optional [ List [ Dict [ str , Any ]]] = None , sticker_ids : Optional [ List [ int ]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to send a message. Parameters: channel_id (int): The ID of the channel which to send the message in. content (Optional[str]): The content of the message. tts (bool): Whether or not to send the message with text-to-speech. embed (Optional[List[Dict[str, Any]]]): The embed to show when sending the message. embeds (Optional[List[Dict[str, Any]]]): The list of embeds to send. message_reference (Optional[Dict[str, Any]]): The messages to reference when sending the message. components (Optional[List[Dict[str, Any]]]): The components to attach to the message. sticker_ids (Optional[List[int]]): The stickers to send with the message. Note: Max embeds that can sent at a time is 10. \"\"\" payload = { \"tts\" : tts } update_payload ( payload , content = content , embeds = embeds , allowed_mentions = allowed_mentions , message_reference = message_reference , components = components , sticker_ids = sticker_ids , ) return await self . request ( \"POST\" , f \"/channels/ { channel_id } /messages\" , json = payload )","title":"HTTPClient"},{"location":"API-Reference/http/#lefi.http.HTTPClient.__init__","text":"Parameters: Name Type Description Default token str The token to use for authorzation. required loop asyncio.AbstractEventLoop The asyncio.AbstractEventLoop to use. required session aiohttp.ClientSession The aiohttp.ClientSession to use for sending requests. required Source code in lefi/http.py def __init__ ( self , token : str , loop : asyncio . AbstractEventLoop ) -> None : \"\"\" Parameters: token (str): The token to use for authorzation. loop (asyncio.AbstractEventLoop): The [asyncio.AbstractEventLoop][] to use. session (aiohttp.ClientSession): The [aiohttp.ClientSession][] to use for sending requests. \"\"\" self . token : str = token self . loop : asyncio . AbstractEventLoop = loop self . session : aiohttp . ClientSession = None # type: ignore","title":"__init__()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.request","text":"Makes a request to the discord API. Parameters: Name Type Description Default method str The method for the request. required path str The endpoint which to send the request to. required **kwargs Any Any extra options to pass to aiohttp.ClientSession.request {} Returns: Type Description Any The data returned from the request. Source code in lefi/http.py async def request ( self , method : str , path : str , ** kwargs ) -> Any : \"\"\" Makes a request to the discord API. Parameters: method (str): The method for the request. path (str): The endpoint which to send the request to. **kwargs (Any): Any extra options to pass to [aiohttp.ClientSession.request][] Returns: The data returned from the request. Raises: [lefi.errors.HTTPException][] if any error was received from the request. \"\"\" if self . session is None or self . session . closed : self . session = await self . _create_session () url = BASE + path async with self . session . request ( method , url , ** kwargs ) as resp : try : data = await resp . json () except aiohttp . ContentTypeError : data = await resp . text () if resp . status in ( 200 , 201 , 204 , 304 ): return data if resp . status == 429 : retry_after = float ( data [ \"retry_after\" ]) # type: ignore await asyncio . sleep ( retry_after ) return await self . request ( method = method , path = path , ** kwargs ) error = self . ERRORS . get ( resp . status , HTTPException ) raise error ( data )","title":"request()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_bot_gateway","text":"A method which gets the gateway url. Returns: Type Description Dict A dict which should contain the url. Source code in lefi/http.py async def get_bot_gateway ( self ) -> Dict : \"\"\" A method which gets the gateway url. Returns: A dict which should contain the url. \"\"\" return await self . request ( \"GET\" , \"/gateway/bot\" )","title":"get_bot_gateway()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.ws_connect","text":"A method which attempts to connect to the websocket. Returns: Type Description aiohttp.ClientWebSocketResponse A aiohttp.ClientWebSocketResponse instance. Source code in lefi/http.py async def ws_connect ( self , url : str ) -> aiohttp . ClientWebSocketResponse : \"\"\" A method which attempts to connect to the websocket. Returns: A [aiohttp.ClientWebSocketResponse][] instance. \"\"\" return await self . session . ws_connect ( url )","title":"ws_connect()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.login","text":"Checks to see if the token given is valid. Source code in lefi/http.py async def login ( self ) -> None : \"\"\" Checks to see if the token given is valid. Raises: ValueError if an invalid token was passed. \"\"\" try : await self . request ( \"GET\" , \"/users/@me\" ) except ( Forbidden , Unauthorized ): raise ValueError ( \"Invalid token\" )","title":"login()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_channel","text":"Makes an API call to get a channel. Parameters: Name Type Description Default channel_id int The channel's ID. required Returns: Type Description Dict[str, Any] A dict representing the channel. Source code in lefi/http.py async def get_channel ( self , channel_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a channel. Parameters: channel_id (int): The channel's ID. Returns: A dict representing the channel. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } \" )","title":"get_channel()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.edit_text_channel","text":"Makes an API call to edit a text channel. Parameters: Name Type Description Default channel_id int The channel id representing the channel to edit. required name Optional[str] The new name for the channel. None type Optional[int] The new type for the channel. None position Optional[int] The new position for the channel. None topic Optional[str] The new topic for the channel. None nsfw Optional[bool] Whether or not the channel should be NSFW. None rate_limit_per_user Optional[int] The new slowmode of the channel. None permissions_overwrites Optional[List[Dict[str, Any]]] The new permission overwrites for the channel. required default_auto_archive_duration Optional[List[Dict[str, Any]]] New time for threads to auto archive. None Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def edit_text_channel ( self , channel_id : int , * , name : Optional [ str ] = None , type : Optional [ int ] = None , position : Optional [ int ] = None , topic : Optional [ str ] = None , nsfw : Optional [ bool ] = None , rate_limit_per_user : Optional [ int ] = None , permission_overwrites : Optional [ List [ Dict [ str , Any ]]] = None , default_auto_archive_duration : Optional [ int ] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a text channel. Parameters: channel_id (int): The channel id representing the channel to edit. name (Optional[str]): The new name for the channel. type (Optional[int]): The new type for the channel. position (Optional[int]): The new position for the channel. topic (Optional[str]): The new topic for the channel. nsfw (Optional[bool]): Whether or not the channel should be NSFW. rate_limit_per_user (Optional[int]): The new slowmode of the channel. permissions_overwrites (Optional[List[Dict[str, Any]]]): The new permission overwrites for the channel. default_auto_archive_duration (Optional[List[Dict[str, Any]]]): New time for threads to auto archive. Returns: The data received from the API after making the call. \"\"\" payload = update_payload ( {}, name = name , type = type , position = position , topic = topic , nsfw = nsfw , rate_limit_per_user = rate_limit_per_user , permission_overwrites = permission_overwrites , default_auto_archive_duration = default_auto_archive_duration , ) return await self . request ( \"PATCH\" , f \"/channels/ { channel_id } \" , json = payload )","title":"edit_text_channel()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.edit_voice_channel","text":"Makes an API call to edit a voice channel. Parameters: Name Type Description Default channel_id int The ID representing the voice channel to edit. required name Optional[str] The new name to give the channel. None position Optional[int] The new position of the channel. None bitrate Optional[int] The new bitrate of the channel. None user_limit Optional[int] The new user limit of the channel. None rtc_region Optional[str] The new rtc region of the channel. None video_quality_mode Optional[int] The new video quality of the channel. None sync_permissions Optional[bool] Whether or not to sync the permissions. None permissions_overwrites Optional[List[Dict[str, Any]]] The new permissions ovewrites for the channel. None Returns: Type Description Dict[str, Any] The data received from the API after the call. Source code in lefi/http.py async def edit_voice_channel ( self , channel_id : int , * , name : Optional [ str ] = None , position : Optional [ int ] = None , bitrate : Optional [ int ] = None , user_limit : Optional [ int ] = None , rtc_region : Optional [ str ] = None , video_quality_mode : Optional [ int ] = None , sync_permissions : Optional [ bool ] = None , permissions_overwrites : Optional [ List [ Dict [ str , Any ]]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to edit a voice channel. Parameters: channel_id (int): The ID representing the voice channel to edit. name (Optional[str]): The new name to give the channel. position (Optional[int]): The new position of the channel. bitrate (Optional[int]): The new bitrate of the channel. user_limit (Optional[int]): The new user limit of the channel. rtc_region (Optional[str]): The new rtc region of the channel. video_quality_mode (Optional[int]): The new video quality of the channel. sync_permissions (Optional[bool]): Whether or not to sync the permissions. permissions_overwrites (Optional[List[Dict[str, Any]]]): The new permissions ovewrites for the channel. Returns: The data received from the API after the call. \"\"\" payload = update_payload ( {}, name = name , position = position , bitrate = bitrate , user_limit = user_limit , rtc_region = rtc_region , video_quality_mode = video_quality_mode , sync_permissions = sync_permissions , permissions_overwrites = permissions_overwrites , ) return await self . request ( \"PATCH\" , f \"/channels/ { channel_id } \" , json = payload )","title":"edit_voice_channel()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_channel_messages","text":"Makes an API call to get a list of messages in a channel. Only returns messages within the range of the parameters passed. Parameters: Name Type Description Default channel_id int The ID representing the channel. required around Optional[int] Gets messages around this message ID. None before Optional[int] Gets messages before this message ID. None after Optional[int] Gets messages after this message ID. None limit int THe amount of messages to grab. 50 Returns: Type Description Dict[str, Any] The data received after making the call. Source code in lefi/http.py async def get_channel_messages ( self , channel_id : int , * , around : Optional [ int ] = None , before : Optional [ int ] = None , after : Optional [ int ] = None , limit : int = 50 , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a list of messages in a channel. Only returns messages within the range of the parameters passed. Parameters: channel_id (int): The ID representing the channel. around (Optional[int]): Gets messages around this message ID. before (Optional[int]): Gets messages before this message ID. after (Optional[int]): Gets messages after this message ID. limit (int): THe amount of messages to grab. Returns: The data received after making the call. \"\"\" params = { \"limit\" : limit } update_payload ( params , around = around , before = before , after = after ) return await self . request ( \"GET\" , f \"/channels/ { channel_id } /messages\" , params = params )","title":"get_channel_messages()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.get_channel_message","text":"Makes an API call to get a specific message by ID. Parameters: Name Type Description Default channel_id int The channel ID which the message is in. required message_id int The messages ID. required Returns: Type Description Dict[str, Any] The data received from the API after making the call. Source code in lefi/http.py async def get_channel_message ( self , channel_id : int , message_id : int ) -> Dict [ str , Any ]: \"\"\" Makes an API call to get a specific message by ID. Parameters: channel_id (int): The channel ID which the message is in. message_id (int): The messages ID. Returns: The data received from the API after making the call. \"\"\" return await self . request ( \"GET\" , f \"/channels/ { channel_id } /messages/ { message_id } \" )","title":"get_channel_message()"},{"location":"API-Reference/http/#lefi.http.HTTPClient.send_message","text":"Makes an API call to send a message. Parameters: Name Type Description Default channel_id int The ID of the channel which to send the message in. required content Optional[str] The content of the message. None tts bool Whether or not to send the message with text-to-speech. False embed Optional[List[Dict[str, Any]]] The embed to show when sending the message. required embeds Optional[List[Dict[str, Any]]] The list of embeds to send. None message_reference Optional[Dict[str, Any]] The messages to reference when sending the message. None components Optional[List[Dict[str, Any]]] The components to attach to the message. None sticker_ids Optional[List[int]] The stickers to send with the message. None Note Max embeds that can sent at a time is 10. Source code in lefi/http.py async def send_message ( self , channel_id : int , content : Optional [ str ] = None , * , tts : bool = False , embeds : Optional [ List [ Dict [ str , Any ]]] = None , allowed_mentions : Optional [ Dict [ str , Any ]] = None , message_reference : Optional [ Dict [ str , Any ]] = None , components : Optional [ List [ Dict [ str , Any ]]] = None , sticker_ids : Optional [ List [ int ]] = None , ) -> Dict [ str , Any ]: \"\"\" Makes an API call to send a message. Parameters: channel_id (int): The ID of the channel which to send the message in. content (Optional[str]): The content of the message. tts (bool): Whether or not to send the message with text-to-speech. embed (Optional[List[Dict[str, Any]]]): The embed to show when sending the message. embeds (Optional[List[Dict[str, Any]]]): The list of embeds to send. message_reference (Optional[Dict[str, Any]]): The messages to reference when sending the message. components (Optional[List[Dict[str, Any]]]): The components to attach to the message. sticker_ids (Optional[List[int]]): The stickers to send with the message. Note: Max embeds that can sent at a time is 10. \"\"\" payload = { \"tts\" : tts } update_payload ( payload , content = content , embeds = embeds , allowed_mentions = allowed_mentions , message_reference = message_reference , components = components , sticker_ids = sticker_ids , ) return await self . request ( \"POST\" , f \"/channels/ { channel_id } /messages\" , json = payload )","title":"send_message()"}]}